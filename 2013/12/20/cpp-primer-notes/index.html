<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ Primer复习笔记 · r14o</title><meta name="description" content="C++ Primer复习笔记 - Ruogu Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://rogers140.github.io/atom.xml" title="r14o"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/ruogu-liu-8a120456" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="https://github.com/rogers140" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ Primer复习笔记</h1><div class="post-info">Dec 20, 2013</div><div class="post-content"><p>C++ Primer也看了一两遍了，但有些东西总是容易忘记或者弄错。最近准备再过一遍，边看边把一些奇奇怪怪的点记录下来。<br><a id="more"></a></p>
<ul>
<li>1.编译器能够查出来的错误有：语法错误、类型错误、声明错误。</li>
<li>2.键盘键入文件结束符，Windows上用Ctrl+z，Unix上用control+d。</li>
<li>3.标准库头文件用&lt;&gt;，自定义非标准头文件用””。</li>
<li>4.char 占8位，int占16位（8位为一个字节，4字节为一个字）。</li>
<li>5.变量初始化有两种方式：复制初始化（用=操作符），直接初始化（用()）。</li>
<li>6.初始化指的是创建变量并赋给它初值；赋值则是擦出原来的值并且使用新值。</li>
<li>7.只有当extern声明于函数外部时，才可以含有初始化式。</li>
<li>8.const引用（例如const int &amp;ref）是指向const对象的引用，而且const对象不能用非const引用。</li>
<li>9.非const引用只能绑定到该引用相同类型的对象，而const可以绑定到不同但是相关类型的对象或者绑定右值。</li>
<li>10.非const变量以及要到运行阶段才知道其值的const变量都不能用来定义数组的维数。</li>
<li>11.C++允许计算数组或者对象的index超出末端，但不允许对此地址进行解引用操作。</li>
<li><p>12.const指针和指向const的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr; <span class="comment">//指向const int的指针</span></div><div class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr; <span class="comment">//const指针</span></div></pre></td></tr></table></figure>
</li>
<li><p>13.如果派生类定义了自己的复制构造函数，该复制构造函数应该显式地使用基类的复制构造函数来初始化基类部分。</p>
</li>
<li>14.派生类析构函数不负责撤销基类对象的成员，因为编译器总是显式地调用派生类对象的基类部分的析构函数，每个析构函数只负责清除自己的成员。</li>
<li>15.虚析构函数存在的意义：父类指针指向子类对象，运行时才可以判断对象的真正类型。所以这种指针在析构时，编译器并不知道其实际指向的类型，只会调用父类的析构函数，并没有动态绑定查找对象的实际析构函数，所以析构行为异常。当父类将析构函数设为虚函数后，即可动态查找到实际对象的析构函数，即子类的析构函数，执行正常的析构动作。</li>
<li>16.在析构函数和构造函数中调用虚函数。在继承关系中，如果存在析构函数或者构造函数调用虚函数，请小心。因为在构造派生类和撤销派生类的时候，对象都是不完整的，所以编译器将对象类型视为在构造函数和析构函数期间发生了变化，所以其中调用的虚函数已经不是他们绑定的类实现的版本了。如果在构造函数或者析构函数中调用虚函数，则运行的是构造函数或者析构函数自身类型的版本。</li>
</ul>
<p>Base类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> cpptest_Base_h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> cpptest_Base_h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> Base&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base()&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"call base constructor."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        newfunc();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">newfunc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"call base new function."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deletefunc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"call base del function."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    ~Base()&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"call base destructor."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        deletefunc();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>Derived类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> cpptest_Base_h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> cpptest_Base_h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Base.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> Derived&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newfunc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"call Derived new function."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deletefunc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"call Derived del function."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>main函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Base.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Derived.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Derived *d =  <span class="keyword">new</span> Derived();</div><div class="line">    <span class="keyword">delete</span> d;</div><div class="line">    getchar();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">call base constructor.</div><div class="line">call base new function.</div><div class="line">call base destructor.</div><div class="line">call base del function.</div></pre></td></tr></table></figure></p>
<ul>
<li>17.派生类想通过自身类型使用所有的函数重载版本，就得在派生类中重定义所有版本，要么一个也不定义。因为编译器调用函数是按名查找，在子类中查到了该函数名就不会再往上继续查找继承链。</li>
<li>18.函数调用的编译器按名查找：<ol>
<li>确定进行函数调用的对象、引用、指针的“静态类型”</li>
<li>在该类中查找函数名，查不到就沿着继承链向父类依次查找，若无法找到，则调用失败</li>
<li>找到该名字之后，就进行常规类型检查，查看函数调用是否合法</li>
<li>如果不合法，则调用失败；如果合法，则编译器生成代码，并考虑是否是虚函数，是否需要加入动态绑定</li>
</ol>
</li>
<li>18.非类型模板形参，在调用函数时将会用值代替，值的类型在模板形参表指定。</li>
<li>19.模板的实参类型推断不支持类型转换。</li>
<li>20.不仅可以特化类模板，还可以特化类成员而不特化类</li>
<li>21.函数重载中，涉及模板函数时，若进行调用时普通函数和模板函数同时匹配的一样好，则普通函数优先。</li>
<li>22.虚继承</li>
<li>23.嵌套类是独立的类，基本上与它们的外围类不相关，因此，外围类和嵌套类的对象是相互独立的，嵌套类的对象不具有外围类所定义的成员，同样，外围的类也不具备嵌套类所定义的成员。</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2014/09/05/summer-summery/" class="prev">PREV</a><a href="/2013/12/18/mobi-vertical/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2016 <a href="https://rogers140.github.io">Ruogu Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>